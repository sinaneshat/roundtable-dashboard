/**
 * Environment Variable Validation Middleware
 *
 * Provides comprehensive validation of required environment variables
 * following production-ready practices with detailed error reporting
 * and integration with existing error handling patterns.
 */

import type { DatabaseConnectionStatus, HealthStatus, OAuthStatus } from '@roundtable/shared/enums';
import { DatabaseConnectionStatuses, HealthStatuses, OAuthStatuses } from '@roundtable/shared/enums';
import { HTTPException } from 'hono/http-exception';
import * as HttpStatusCodes from 'stoker/http-status-codes';

import { createError } from '@/common/error-handling';
import { validateEnvironmentVariables } from '@/common/fetch-utilities';

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

export type SafeEnvironmentSummary = {
  NODE_ENV: string;
  LOG_LEVEL: string;
  ENVIRONMENT_VERIFIED: boolean;
  DATABASE_CONNECTION_STATUS: DatabaseConnectionStatus;
  OAUTH_STATUS: OAuthStatus;
  TIMESTAMP: string;
};

// ============================================================================
// ENVIRONMENT VARIABLE DEFINITIONS
// ============================================================================

/**
 * CloudflareEnv is globally available from cloudflare-env.d.ts
 * Generated by Wrangler and available throughout the application
 */

/**
 * Critical environment variables that must be present and valid
 * These are required for core application functionality
 */
export const CRITICAL_ENV_VARS = [
  'BETTER_AUTH_SECRET',
  'BETTER_AUTH_URL',
  'NODE_ENV',
] as const;

/**
 * Email/Communication environment variables
 * Required for AWS SES email functionality
 */
export const EMAIL_ENV_VARS = [
  'FROM_EMAIL',
  'AWS_SES_ACCESS_KEY_ID',
  'AWS_SES_SECRET_ACCESS_KEY',
  'AWS_SES_REGION',
  'SES_REPLY_TO_EMAIL',
  'SES_VERIFIED_EMAIL',
] as const;

/**
 * Google OAuth environment variables
 * Required for social authentication
 */
export const OAUTH_ENV_VARS = [
  'AUTH_GOOGLE_ID',
  'AUTH_GOOGLE_SECRET',
] as const;

/**
 * Optional environment variables that have defaults or are feature-specific
 */
export const OPTIONAL_ENV_VARS = [
  'TURNSTILE_SITE_KEY',
  'TURNSTILE_SECRET_KEY',
  'R2_PUBLIC_URL',
] as const;

// ============================================================================
// VALIDATION FUNCTIONS
// ============================================================================

/**
 * Validates URL format for environment variables
 */
function isValidUrl(value: string): boolean {
  try {
    void new URL(value);
    return true;
  } catch {
    return false;
  }
}

/**
 * Validates email format
 */
function isValidEmail(value: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@][^\s.@]*\.[^\s@]+$/;
  return emailRegex.test(value);
}

/**
 * Validates AWS region format
 */
function isValidAwsRegion(value: string): boolean {
  const regionRegex = /^[a-z]{2}-[a-z]+-\d+$/;
  return regionRegex.test(value);
}

/**
 * Comprehensive environment variable validation with detailed error reporting
 */
export function validateEnvironmentConfiguration(env: CloudflareEnv): {
  isValid: boolean;
  errors: string[];
  warnings: string[];
  missingCritical: string[];
  missingOptional: string[];
} {
  const errors: string[] = [];
  const warnings: string[] = [];
  const missingCritical: string[] = [];
  const missingOptional: string[] = [];

  // Check critical environment variables
  for (const varName of CRITICAL_ENV_VARS) {
    if (!env[varName]) {
      missingCritical.push(varName);
      errors.push(`Missing critical environment variable: ${varName}`);
    }
  }

  // Validate specific environment variable formats
  if (env.BETTER_AUTH_URL && !isValidUrl(env.BETTER_AUTH_URL)) {
    errors.push('BETTER_AUTH_URL must be a valid URL');
  }

  if (env.R2_PUBLIC_URL && !isValidUrl(env.R2_PUBLIC_URL)) {
    errors.push('R2_PUBLIC_URL must be a valid URL');
  }

  // Validate Google OAuth configuration
  for (const varName of OAUTH_ENV_VARS) {
    if (!env[varName]) {
      missingOptional.push(varName);
      warnings.push(`Missing OAuth configuration: ${varName}`);
    }
  }

  // Validate email configuration
  for (const varName of EMAIL_ENV_VARS) {
    if (!env[varName]) {
      missingOptional.push(varName);
      warnings.push(`Missing email configuration: ${varName}`);
    }
  }

  if (env.FROM_EMAIL && !isValidEmail(env.FROM_EMAIL)) {
    errors.push('FROM_EMAIL must be a valid email address');
  }

  if (env.SES_REPLY_TO_EMAIL && !isValidEmail(env.SES_REPLY_TO_EMAIL)) {
    errors.push('SES_REPLY_TO_EMAIL must be a valid email address');
  }

  if (env.SES_VERIFIED_EMAIL && !isValidEmail(env.SES_VERIFIED_EMAIL)) {
    errors.push('SES_VERIFIED_EMAIL must be a valid email address');
  }

  // Validate AWS configuration
  if (env.AWS_SES_REGION && !isValidAwsRegion(env.AWS_SES_REGION)) {
    errors.push('AWS_SES_REGION must be a valid AWS region format (e.g., us-east-1)');
  }

  // Check for missing email variables (as a group)
  const hasSomeEmailConfig = EMAIL_ENV_VARS.some(varName => env[varName]);
  const hasAllEmailConfig = EMAIL_ENV_VARS.every(varName => env[varName]);

  if (hasSomeEmailConfig && !hasAllEmailConfig) {
    const missingEmailVars = EMAIL_ENV_VARS.filter(varName => !env[varName]);
    warnings.push(`Incomplete email configuration - missing: ${missingEmailVars.join(', ')}`);
  }

  // Validate boolean environment variables
  if (env.MAINTENANCE !== undefined && typeof env.MAINTENANCE === 'string' && !['true', 'false'].includes(env.MAINTENANCE)) {
    warnings.push(`MAINTENANCE should be 'true' or 'false'`);
  }

  // Check for required Cloudflare bindings (Critical for Better Auth)
  if (!env.DB) {
    errors.push('Missing required Cloudflare D1 database binding (DB) - Better Auth requires database access');
  } else {
    // Intentionally empty
    // Validate D1 database binding has required methods for Better Auth transactions
    try {
      if (typeof env.DB.prepare !== 'function') {
        errors.push('D1 database binding (DB) is invalid - missing prepare method for Better Auth');
      }
    } catch {
      warnings.push('Unable to validate D1 database binding methods');
    }
  }

  if (!env.KV) {
    warnings.push('Missing KV namespace binding (KV) - session caching may be limited');
  }

  if (!env.UPLOADS_R2_BUCKET) {
    warnings.push('Missing R2 bucket binding (UPLOADS_R2_BUCKET) - file upload functionality will be unavailable');
  }

  const isValid = errors.length === 0 && missingCritical.length === 0;

  return {
    isValid,
    errors,
    warnings,
    missingCritical,
    missingOptional,
  };
}

// ============================================================================
// MIDDLEWARE IMPLEMENTATION
// ============================================================================

/**
 * Environment validation middleware that runs on application startup
 * Validates all required environment variables and provides detailed error reporting
 * Uses Hono context for per-request env access in Cloudflare Workers
 */
export function createEnvironmentValidationMiddleware() {
  return async (c: { env: CloudflareEnv }, next: () => Promise<void>) => {
    // Use Hono context env directly - no need for external import
    const env = c.env;
    if (!env) {
      // Fallback when env is not available - skip validation
      return next();
    }

    // Skip validation in test environment
    // NODE_ENV is inlined at build time, so process.env is acceptable here
    if (env.NODE_ENV === 'test' || process.env.NODE_ENV === 'test') {
      return next();
    }

    const validation = validateEnvironmentConfiguration(env);

    // Validate results
    if (!validation.isValid) {
      // In production, fail fast on critical errors
      if (env.NODE_ENV === 'production' && validation.missingCritical.length > 0) {
        throw new HTTPException(HttpStatusCodes.INTERNAL_SERVER_ERROR, {
          message: 'Application misconfiguration detected',
        });
      }

      // In development, provide detailed error information
      if (env.NODE_ENV === 'development') {
        const errorDetails = [
          ...validation.errors,
          ...validation.missingCritical.map(v => `Missing critical: ${v}`),
        ].join('\n');

        throw createError.internal(`Environment validation failed:\n${errorDetails}`);
      }
    }

    return next();
  };
}

/**
 * Validates specific environment variables required for a service
 * Can be used by individual services for targeted validation
 */
export function validateServiceEnvironment(
  env: CloudflareEnv,
  required: readonly (keyof CloudflareEnv)[],
  _serviceName: string,
): void {
  // Use the original env parameter directly since validateEnvironmentVariables expects CloudflareEnv
  validateEnvironmentVariables(env, [...required]);
}

/**
 * Health check function that returns environment validation status
 * Can be used by health check endpoints
 * âœ… ENUM PATTERN: Uses HealthStatus type and HealthStatuses constants
 */
export function getEnvironmentHealthStatus(env: CloudflareEnv): {
  status: HealthStatus;
  validation: ReturnType<typeof validateEnvironmentConfiguration>;
} {
  const validation = validateEnvironmentConfiguration(env);

  let status: HealthStatus = HealthStatuses.HEALTHY;

  if (validation.errors.length > 0 || validation.missingCritical.length > 0) {
    status = HealthStatuses.UNHEALTHY;
  } else if (validation.warnings.length > 0 || validation.missingOptional.length > 3) {
    status = HealthStatuses.DEGRADED;
  }

  return { status, validation };
}

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Creates a development-friendly environment configuration summary
 * Safe for logging (excludes sensitive values)
 * Using discriminated union pattern for maximum type safety (Context7 Pattern)
 */
export function createEnvironmentSummary(env: CloudflareEnv): SafeEnvironmentSummary {
  // Determine database connection status
  let databaseStatus: DatabaseConnectionStatus = DatabaseConnectionStatuses.PENDING;
  if (env.DB) {
    databaseStatus = DatabaseConnectionStatuses.CONNECTED;
  } else {
    databaseStatus = DatabaseConnectionStatuses.DISCONNECTED;
  }

  // Determine OAuth status
  let oauthStatus: OAuthStatus = OAuthStatuses.MISSING;
  if (env.AUTH_GOOGLE_ID && env.AUTH_GOOGLE_SECRET) {
    // Basic validation - check if they look like real OAuth credentials
    const hasValidFormat = env.AUTH_GOOGLE_ID.includes('.apps.googleusercontent.com')
      && env.AUTH_GOOGLE_SECRET.startsWith('GOCSPX-');
    oauthStatus = hasValidFormat ? OAuthStatuses.CONFIGURED : OAuthStatuses.INVALID;
  }

  return {
    NODE_ENV: env.NODE_ENV || 'development',
    LOG_LEVEL: 'info',
    ENVIRONMENT_VERIFIED: !!(env.DB && env.BETTER_AUTH_SECRET && env.BETTER_AUTH_URL),
    DATABASE_CONNECTION_STATUS: databaseStatus,
    OAUTH_STATUS: oauthStatus,
    TIMESTAMP: new Date().toISOString(),
  };
}
