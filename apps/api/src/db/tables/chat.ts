import {
  CHANGELOG_TYPES,
  CHAT_MODES,
  DEFAULT_CHAT_MODE,
  DEFAULT_MESSAGE_STATUS,
  DEFAULT_ROUND_EXECUTION_TABLE_STATUS,
  DEFAULT_THREAD_STATUS,
  MESSAGE_ROLES,
  MESSAGE_STATUSES,
  ROUND_EXECUTION_TABLE_STATUSES,
  THREAD_STATUSES,
} from '@roundtable/shared/enums';
import { sql } from 'drizzle-orm';
import { check, index, integer, sqliteTable, text, uniqueIndex } from 'drizzle-orm/sqlite-core';

import type {
  DbChangelogData,
  DbCustomRoleMetadata,
  DbMessageMetadata,
  DbMessageParts,
  DbModelRoles,
  DbParticipantSettings,
  DbPreSearchTableData,
  DbThreadMetadata,
  DbToolCalls,
  DbUserPresetMetadata,
} from '@/db/schemas/chat-metadata';

import { user } from './auth';
import { chatProject } from './project';

/**
 * Chat Threads
 * Container for multi-model conversations with configuration
 */
export const chatThread = sqliteTable('chat_thread', {
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
  enableWebSearch: integer('enable_web_search', { mode: 'boolean' })
    .notNull()
    .default(false), // Allow participants to browse web for information

  id: text('id').primaryKey(),

  isAiGeneratedTitle: integer('is_ai_generated_title', { mode: 'boolean' })
    .notNull()
    .default(false), // Track if title was generated by AI (vs default "New Chat")
  isFavorite: integer('is_favorite', { mode: 'boolean' })
    .notNull()
    .default(false), // User can mark threads as favorites
  isPublic: integer('is_public', { mode: 'boolean' })
    .notNull()
    .default(false), // Public threads can be viewed without authentication
  lastMessageAt: integer('last_message_at', { mode: 'timestamp_ms' }),
  // ✅ TYPE-SAFE: Strictly typed metadata using discriminated union schema
  metadata: text('metadata', { mode: 'json' }).$type<DbThreadMetadata>(),
  mode: text('mode', { enum: CHAT_MODES })
    .notNull()
    .default(DEFAULT_CHAT_MODE),
  // Store previous slug when AI-generated title updates it - both slugs remain valid for thread access
  previousSlug: text('previous_slug'), // nullable - only set after first AI title generation
  // Project association (optional - threads can exist without projects)
  // CASCADE: When project is deleted, all associated threads are deleted
  projectId: text('project_id')
    .references(() => chatProject.id, { onDelete: 'cascade' }),
  slug: text('slug').notNull().unique(), // SEO-friendly URL slug (e.g., "product-strategy-abc123")
  status: text('status', { enum: THREAD_STATUSES })
    .notNull()
    .default(DEFAULT_THREAD_STATUS),
  title: text('title').notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  // Optimistic locking - prevents lost updates in concurrent modifications
  version: integer('version').notNull().default(1),
}, table => [
  index('chat_thread_user_idx').on(table.userId),
  index('chat_thread_project_idx').on(table.projectId),
  index('chat_thread_status_idx').on(table.status),
  index('chat_thread_updated_idx').on(table.updatedAt),
  index('chat_thread_slug_idx').on(table.slug), // Fast lookups by slug for public sharing
  index('chat_thread_previous_slug_idx').on(table.previousSlug), // Fast lookups by previous slug
  index('chat_thread_favorite_idx').on(table.isFavorite),
  index('chat_thread_public_idx').on(table.isPublic),
  // ✅ PERF: Composite index for public thread list queries (isPublic + status filter)
  index('chat_thread_public_status_idx').on(table.isPublic, table.status),
]);

/**
 * Custom Roles
 * User-defined role templates with system prompts that can be reused
 * Examples: "The Devil's Advocate", "The Fact Checker", "The Creative Ideator"
 * Defined before chatParticipant to allow forward reference
 */
export const chatCustomRole = sqliteTable('chat_custom_role', {
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
  description: text('description'), // Brief description of the role
  id: text('id').primaryKey(),
  // ✅ TYPE-SAFE: Strictly typed metadata for custom roles
  metadata: text('metadata', { mode: 'json' }).$type<DbCustomRoleMetadata>(),
  name: text('name').notNull(), // e.g., "The Devil's Advocate"
  systemPrompt: text('system_prompt'), // Optional - if null, generated at runtime from role name
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
}, table => [
  index('chat_custom_role_user_idx').on(table.userId),
  index('chat_custom_role_name_idx').on(table.name),
]);

/**
 * User Presets
 * User-defined preset configurations for chat mode and participant roles
 * Allows saving and reusing preferred chat configurations
 */
export const chatUserPreset = sqliteTable('chat_user_preset', {
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
  id: text('id').primaryKey(),
  // ✅ TYPE-SAFE: Strictly typed metadata for user presets
  metadata: text('metadata', { mode: 'json' }).$type<DbUserPresetMetadata>(),
  mode: text('mode', { enum: CHAT_MODES })
    .notNull()
    .default(DEFAULT_CHAT_MODE),
  // Array of model-role pairs that define the preset configuration
  // ✅ TYPE-SAFE: Type inferred from Zod schema in chat-metadata.ts
  modelRoles: text('model_roles', { mode: 'json' }).$type<DbModelRoles>().notNull(),
  name: text('name').notNull(), // e.g., "Research Team", "Code Review Squad"
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
}, table => [
  index('chat_user_preset_user_idx').on(table.userId),
  index('chat_user_preset_name_idx').on(table.name),
]);

/**
 * Chat Participants
 * Models participating in a thread with their assigned roles
 * Can use custom role templates or inline role definitions
 */
export const chatParticipant = sqliteTable('chat_participant', {
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
  customRoleId: text('custom_role_id')
    .references(() => chatCustomRole.id, { onDelete: 'set null' }), // Reference to saved custom role (optional)
  id: text('id').primaryKey(),
  isEnabled: integer('is_enabled', { mode: 'boolean' })
    .notNull()
    .default(true),
  modelId: text('model_id').notNull(), // e.g., 'anthropic/claude-sonnet-4.5', 'openai/gpt-5'
  priority: integer('priority').notNull().default(0), // Order in which models respond
  role: text('role'), // Optional role name (from custom role or inline) - e.g., "The Ideator", "Devil's Advocate"
  // ✅ TYPE-SAFE: Strictly typed settings (temperature, maxTokens, systemPrompt)
  settings: text('settings', { mode: 'json' }).$type<DbParticipantSettings>(),
  threadId: text('thread_id')
    .notNull()
    .references(() => chatThread.id, { onDelete: 'cascade' }),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
}, table => [
  // Indexes for query performance
  index('chat_participant_thread_idx').on(table.threadId),
  index('chat_participant_priority_idx').on(table.priority),
  index('chat_participant_custom_role_idx').on(table.customRoleId),

  // ============================================================================
  // DATABASE-LEVEL CONSTRAINTS (Second layer of protection)
  // ============================================================================

  // ✅ PRIORITY CONSTRAINT: Ensure priority is non-negative
  // Rationale: Priority determines response order, must be >= 0
  check('check_priority_non_negative', sql`${table.priority} >= 0`),

  // ✅ UNIQUE CONSTRAINT: Prevent duplicate participants per thread
  // BUG FIX: Without this, race conditions between PATCH and streaming handlers
  // could create multiple participants with the same modelId in one thread.
  // This is the database-level protection to ensure data integrity.
  uniqueIndex('chat_participant_thread_model_unique').on(table.threadId, table.modelId),
]);

/**
 * Chat Thread Changelog
 * Tracks configuration changes to threads (participants, mode)
 * Shows between conversation rounds when user modifies thread configuration
 *
 * ✅ EVENT-BASED ROUND TRACKING: Like messages and analysis, changelog entries
 * are tied to specific rounds. They appear BETWEEN rounds to show what changed
 * before the next user prompt was submitted.
 *
 * Example flow:
 * - Round 1: User asks question, models respond
 * - [Analysis for Round 1]
 * - User changes mode from "brainstorming" to "analyzing"
 * - User reorders participants
 * - User submits next message → CHANGELOG CREATED for Round 2
 * - [Changelog showing mode change + reordering] ← Shows BEFORE Round 2 messages
 * - Round 2: User asks question, models respond with new config
 */
export const chatThreadChangelog = sqliteTable('chat_thread_changelog', {
  // ✅ TYPE-SAFE: Discriminated union by 'type' field - no escape hatches
  // Four change types: 'participant', 'participant_role', 'mode_change', 'participant_reorder'
  changeData: text('change_data', { mode: 'json' }).$type<DbChangelogData>().notNull(),
  changeSummary: text('change_summary').notNull(), // Human-readable summary
  changeType: text('change_type', { enum: CHANGELOG_TYPES }).notNull(),
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
  id: text('id').primaryKey(),
  // ✅ ROUND TRACKING: Which round does this changelog belong to?
  // Changelog for round N appears BEFORE round N messages (showing what changed)
  // ✅ 0-BASED: First round is 0
  roundNumber: integer('round_number')
    .notNull()
    .default(0), // ✅ 0-BASED: Default to round 0
  threadId: text('thread_id')
    .notNull()
    .references(() => chatThread.id, { onDelete: 'cascade' }),
}, table => [
  index('chat_thread_changelog_thread_idx').on(table.threadId),
  index('chat_thread_changelog_type_idx').on(table.changeType),
  index('chat_thread_changelog_created_idx').on(table.createdAt),
  // ✅ ROUND TRACKING INDEX: Efficient queries by thread + round
  index('chat_thread_changelog_thread_round_idx').on(table.threadId, table.roundNumber),
]);

/**
 * Chat Messages
 * Individual messages in threads (user input + model responses)
 *
 * ✅ AI SDK v6 ALIGNMENT: Schema matches UIMessage format from @ai-sdk/react
 * - parts[] array stores message content (text, reasoning, tool-result, etc.)
 * - Direct mapping to/from UIMessage without transformation overhead
 * - Supports multi-part messages (text + reasoning in single message)
 *
 * Reference: https://sdk.vercel.ai/docs/ai-sdk-ui/chatbot#message-format
 */
export const chatMessage = sqliteTable('chat_message', {
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
  id: text('id').primaryKey(),
  // ✅ TYPE-SAFE: Discriminated union by 'role' field - strictly validated metadata
  // Three message types: user, assistant/participant, pre-search/system
  // Each type has different required fields enforced by discriminated union
  metadata: text('metadata', { mode: 'json' }).$type<DbMessageMetadata>(),
  participantId: text('participant_id')
    .references(() => chatParticipant.id, { onDelete: 'set null' }), // null for user messages

  // ✅ AI SDK v6 PATTERN: Store parts[] array matching UIMessage.parts structure
  // Eliminates transformation overhead - direct pass-through to/from frontend
  // Supports: text parts, reasoning parts (Claude extended thinking), tool parts
  // Tool parts: tool-call (function invocation) and tool-result (execution result)
  //
  // ✅ ZERO-DOWNTIME MIGRATION: TypeScript-only change, existing messages still valid
  // Existing messages without tool parts continue to work without modification
  // ✅ TYPE-SAFE: Type inferred from Zod schema in chat-metadata.ts (DbMessageParts)
  parts: text('parts', { mode: 'json' }).notNull().$type<DbMessageParts>(),

  role: text('role', { enum: MESSAGE_ROLES })
    .notNull()
    .default('assistant'),

  // ✅ ROUND TRACKING: Event-based round number for reliable analysis placement
  // Round = User message + all participant responses
  // Eliminates fragile date/time calculations on frontend
  // ✅ 0-BASED: First round is 0
  roundNumber: integer('round_number')
    .notNull()
    .default(0), // ✅ 0-BASED: Default to round 0

  threadId: text('thread_id')
    .notNull()
    .references(() => chatThread.id, { onDelete: 'cascade' }),

  // ✅ TOOL SUPPORT: Store tool calls made by the model (separate from tool results in parts[])
  // ✅ TYPE-SAFE: Type inferred from Zod schema in chat-metadata.ts (DbToolCalls)
  toolCalls: text('tool_calls', { mode: 'json' }).$type<DbToolCalls>(),
}, table => [
  index('chat_message_thread_idx').on(table.threadId),
  index('chat_message_created_idx').on(table.createdAt),
  index('chat_message_participant_idx').on(table.participantId),
  // ✅ Composite index for efficient message filtering by role
  index('chat_message_role_idx').on(table.role),
  // ✅ Composite index for paginated message queries (thread + sort)
  index('chat_message_thread_created_idx').on(table.threadId, table.createdAt),
  // ✅ ROUND TRACKING INDEX: Efficient queries by thread + round for analysis placement
  index('chat_message_thread_round_idx').on(table.threadId, table.roundNumber),
]);

/**
 * Pre-Search Results
 * Stores web search results executed BEFORE participant streaming
 * Follows same pattern as moderator analysis for consistency
 */
export const chatPreSearch = sqliteTable('chat_pre_search', {
  // ✅ Completion timestamp (null until status = 'complete')
  completedAt: integer('completed_at', { mode: 'timestamp_ms' }),
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
  // ✅ Error tracking for failed searches
  errorMessage: text('error_message'),
  id: text('id').primaryKey(),
  roundNumber: integer('round_number').notNull(), // ✅ 0-BASED: First round is 0
  // Store the full search results as JSON
  // ✅ NULLABLE: Only populated once search completes successfully
  // ✅ TAVILY-ENHANCED: Includes images, auto-parameters, enhanced metadata
  // ✅ TYPE-SAFE: Type inferred from Zod schema in chat-metadata.ts (DbPreSearchTableData)
  searchData: text('search_data', { mode: 'json' }).$type<DbPreSearchTableData>(),
  // ✅ CRITICAL: Status field for idempotency and state tracking
  // Prevents duplicate searches on page refresh
  // Uses MESSAGE_STATUSES for consistency (pending/streaming/completed/failed)
  status: text('status', { enum: MESSAGE_STATUSES })
    .notNull()
    .default(DEFAULT_MESSAGE_STATUS), // pending -> streaming -> completed/failed
  threadId: text('thread_id')
    .notNull()
    .references(() => chatThread.id, { onDelete: 'cascade' }),
  userQuery: text('user_query').notNull(), // The user's search query
}, table => [
  index('chat_pre_search_thread_idx').on(table.threadId),
  index('chat_pre_search_round_idx').on(table.threadId, table.roundNumber),
  index('chat_pre_search_created_idx').on(table.createdAt),
  index('chat_pre_search_status_idx').on(table.status),
  // ✅ UNIQUE CONSTRAINT: Only one pre-search per thread + round
  uniqueIndex('chat_pre_search_thread_round_unique').on(table.threadId, table.roundNumber),
]);

/**
 * Round Execution
 * Tracks round lifecycle with durable state for robust streaming resumption.
 * Database as source of truth - KV is just a resumption hint.
 *
 * Status Flow:
 * pending → pre_search → participants → moderator → completed
 *     ↓         ↓            ↓            ↓
 *   failed    failed       failed       failed
 *
 * Key benefits:
 * - Survives worker timeouts (30s Cloudflare limit)
 * - Enables self-healing via scheduled recovery
 * - Idempotent: re-triggering same round/participant is safe
 */
export const roundExecution = sqliteTable('round_execution', {
  // Recovery tracking
  attempts: integer('attempts').notNull().default(0),

  // Timestamps
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),

  errorMessage: text('error_message'),

  // Primary key
  id: text('id').primaryKey(),

  lastAttemptAt: integer('last_attempt_at', { mode: 'timestamp_ms' }),
  moderatorCompletedAt: integer('moderator_completed_at', { mode: 'timestamp_ms' }),
  participantsCompleted: integer('participants_completed').notNull().default(0),
  participantsTotal: integer('participants_total').notNull().default(0),

  // Progress tracking
  preSearchCompletedAt: integer('pre_search_completed_at', { mode: 'timestamp_ms' }),
  // Round tracking (0-based)
  roundNumber: integer('round_number').notNull().default(0),
  // State machine status
  status: text('status', { enum: ROUND_EXECUTION_TABLE_STATUSES })
    .notNull()
    .default(DEFAULT_ROUND_EXECUTION_TABLE_STATUS),

  // Thread relationship
  threadId: text('thread_id')
    .notNull()
    .references(() => chatThread.id, { onDelete: 'cascade' }),

  updatedAt: integer('updated_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
  // User context for queue messages
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
}, table => [
  // Unique constraint: one execution per thread + round
  uniqueIndex('round_execution_thread_round_unique').on(table.threadId, table.roundNumber),
  // Query optimization indexes
  index('round_execution_status_idx').on(table.status),
  index('round_execution_thread_idx').on(table.threadId),
  index('round_execution_user_idx').on(table.userId),
  // Recovery cron queries by status + lastAttemptAt
  index('round_execution_recovery_idx').on(table.status, table.lastAttemptAt),
]);

// Relations moved to relations.ts to break circular dependencies
