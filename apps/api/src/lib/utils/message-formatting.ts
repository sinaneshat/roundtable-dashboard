import { MessageRoles } from '@roundtable/shared/enums';
import type { UIMessage } from 'ai';

import { getAssistantMetadata, getRoundNumber, isModeratorMessage, isTextPart } from '@/lib/utils';
import type { ChatParticipant } from '@/routes/chat/schema';

export function getParticipantFromMessage(
  message: UIMessage,
  participants: ChatParticipant[],
): ChatParticipant | undefined {
  const metadata = getAssistantMetadata(message.metadata);
  if (metadata?.participantId) {
    return participants.find(p => p.id === metadata.participantId);
  }
  return undefined;
}

export function getParticipantDisplayName(participant: ChatParticipant | undefined): string {
  if (!participant)
    return 'Assistant';
  if (participant.role)
    return participant.role;

  const modelName = participant.modelId.split('/').pop() ?? participant.modelId;
  return modelName
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

export function getMessageTextContent(message: UIMessage): string {
  if (!message.parts || message.parts.length === 0) {
    return '';
  }
  return message.parts.filter(isTextPart).map(part => part.text).join('\n\n');
}

export function formatRoundAsMarkdown(
  messages: UIMessage[],
  participants: ChatParticipant[],
  roundNumber: number,
  options?: {
    threadTitle?: string;
    moderatorText?: string;
  },
): string {
  const lines: string[] = [];
  const timestamp = new Date().toISOString().split('T')[0];

  if (options?.threadTitle) {
    lines.push(`# ${options.threadTitle}`);
    lines.push('');
  }
  lines.push(`## Round ${roundNumber}`);
  lines.push('');
  lines.push(`*Exported on ${timestamp}*`);
  lines.push('');
  lines.push('---');
  lines.push('');

  for (const message of messages) {
    const content = getMessageTextContent(message);
    if (!content.trim())
      continue;

    if (message.role === MessageRoles.USER) {
      lines.push('### User');
      lines.push('');
      lines.push(content);
      lines.push('');
    } else if (message.role === MessageRoles.ASSISTANT) {
      const participant = getParticipantFromMessage(message, participants);
      const displayName = getParticipantDisplayName(participant);
      lines.push(`### ${displayName}`);
      if (participant?.modelId) {
        lines.push(`*Model: ${participant.modelId}*`);
      }
      lines.push('');
      lines.push(content);
      lines.push('');
    }
  }

  if (options?.moderatorText) {
    lines.push('---');
    lines.push('');
    lines.push('### Moderator');
    lines.push('');
    lines.push(options.moderatorText);
    lines.push('');
  }

  lines.push('---');
  lines.push('');
  lines.push('*Generated by Roundtable*');

  return lines.join('\n');
}

export function formatThreadAsMarkdown(
  messages: UIMessage[],
  participants: ChatParticipant[],
  threadTitle?: string,
): string {
  const lines: string[] = [];
  const timestamp = new Date().toISOString().split('T')[0];

  if (threadTitle) {
    lines.push(`# ${threadTitle}`);
    lines.push('');
  }

  lines.push(`*Exported on ${timestamp}*`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Group messages by round number
  const messagesByRound = new Map<number, UIMessage[]>();
  for (const message of messages) {
    const roundNumber = getRoundNumber(message.metadata) ?? 0;
    const existing = messagesByRound.get(roundNumber);
    if (existing) {
      existing.push(message);
    } else {
      messagesByRound.set(roundNumber, [message]);
    }
  }

  // Sort rounds and format each
  const sortedRounds = Array.from(messagesByRound.keys()).sort((a, b) => a - b);

  for (const roundNumber of sortedRounds) {
    const roundMessages = messagesByRound.get(roundNumber) ?? [];

    lines.push(`## Round ${roundNumber}`);
    lines.push('');

    // Process messages in order: user first, then participants, then moderator
    const userMessages = roundMessages.filter(m => m.role === MessageRoles.USER);
    const participantMessages = roundMessages.filter(
      m => m.role === MessageRoles.ASSISTANT && !isModeratorMessage(m),
    );
    const moderatorMessages = roundMessages.filter(m => isModeratorMessage(m));

    // User messages
    for (const message of userMessages) {
      const content = getMessageTextContent(message);
      if (!content.trim())
        continue;
      lines.push('### User');
      lines.push('');
      lines.push(content);
      lines.push('');
    }

    // Participant messages
    for (const message of participantMessages) {
      const content = getMessageTextContent(message);
      if (!content.trim())
        continue;
      const participant = getParticipantFromMessage(message, participants);
      const displayName = getParticipantDisplayName(participant);
      lines.push(`### ${displayName}`);
      if (participant?.modelId) {
        lines.push(`*Model: ${participant.modelId}*`);
      }
      lines.push('');
      lines.push(content);
      lines.push('');
    }

    // Moderator message
    for (const message of moderatorMessages) {
      const content = getMessageTextContent(message);
      if (!content.trim())
        continue;
      lines.push('### Council Summary');
      lines.push('');
      lines.push(content);
      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  lines.push('*Generated by Roundtable*');

  return lines.join('\n');
}
