/**
 * useAnalyzePromptStream - SSE Streaming Hook for Auto Mode Config Analysis
 *
 * Streams configuration recommendations from the analyze endpoint.
 * Updates partial configs in real-time as they're generated by AI.
 *
 * @example
 * const { streamConfig, isStreaming, error, partialConfig } = useAnalyzePromptStream();
 *
 * const handleSubmit = async () => {
 *   const hasImageFiles = attachments.some(att => isImage(att.file.type));
 *   const hasDocumentFiles = attachments.some(att => isDocument(att.file.type));
 *   const finalConfig = await streamConfig({ prompt, hasImageFiles, hasDocumentFiles });
 *   // Apply finalConfig to store - models filtered by capabilities
 * };
 */

import { AnalyzePromptSseEvents } from '@roundtable/shared';
import { useCallback, useRef, useState } from 'react';
import { z } from 'zod';

import type { AnalyzePromptPayload } from '@/services/api';
import { analyzePromptStreamService } from '@/services/api';
import { AUTO_MODE_FALLBACK_CONFIG } from '@/stores/chat/store-defaults';

// ============================================================================
// TYPE SCHEMAS - Zod-based for proper type inference
// ============================================================================

/**
 * Internal state schema for the hook
 */
const AnalyzePromptStreamStateSchema = z.object({
  error: z.custom<Error | null>(),
  isStreaming: z.boolean(),
  partialConfig: z.custom<Partial<AnalyzePromptPayload> | null>(),
});
type AnalyzePromptStreamState = z.infer<typeof AnalyzePromptStreamStateSchema>;

/**
 * Stream config options schema
 */
const _StreamConfigOptionsSchema = z.object({
  /**
   * âœ… CLIENT-PROVIDED MODEL LIST: Pre-filtered accessible model IDs
   * Frontend filters by: user tier + vision capability + document capability
   * This ensures AI only picks from models the user can actually use
   */
  accessibleModelIds: z.array(z.string()).optional(),
  /** Whether document files (PDFs, DOC, etc.) are attached - requires supports_file */
  hasDocumentFiles: z.boolean().optional(),
  /** Whether image files are attached - requires supports_vision */
  hasImageFiles: z.boolean().optional(),
  prompt: z.string(),
});
type StreamConfigOptions = z.infer<typeof _StreamConfigOptionsSchema>;

/**
 * Full result schema - state + functions
 */
const _AnalyzePromptStreamResultSchema = AnalyzePromptStreamStateSchema.extend({
  abort: z.custom<() => void>(),
  reset: z.custom<() => void>(),
  streamConfig: z.custom<(options: StreamConfigOptions) => Promise<AnalyzePromptPayload | null>>(),
});
type AnalyzePromptStreamResult = z.infer<typeof _AnalyzePromptStreamResultSchema>;

export function useAnalyzePromptStream(): AnalyzePromptStreamResult {
  const [state, setState] = useState<AnalyzePromptStreamState>({
    error: null,
    isStreaming: false,
    partialConfig: null,
  });

  const abortControllerRef = useRef<AbortController | null>(null);

  const abort = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
  }, []);

  const reset = useCallback(() => {
    abort();
    setState({
      error: null,
      isStreaming: false,
      partialConfig: null,
    });
  }, [abort]);

  const streamConfig = useCallback(async (options: StreamConfigOptions): Promise<AnalyzePromptPayload | null> => {
    const { accessibleModelIds, hasDocumentFiles = false, hasImageFiles = false, prompt } = options;

    // Abort any existing stream
    abort();

    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    setState({
      error: null,
      isStreaming: true,
      partialConfig: null,
    });

    try {
      const response = await analyzePromptStreamService({
        json: {
          accessibleModelIds,
          hasDocumentFiles,
          hasImageFiles,
          prompt,
        },
      });

      if (!response.ok) {
        throw new Error(`Analysis failed: ${response.statusText}`);
      }

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();

      if (!reader) {
        throw new Error('No response body');
      }

      let buffer = '';
      let currentEvent = '';
      let currentData = '';
      let finalConfig: AnalyzePromptPayload | null = null;

      const processEvent = (event: string, data: string) => {
        try {
          if (event === AnalyzePromptSseEvents.START) {
            // Stream started - nothing to do
          } else if (event === AnalyzePromptSseEvents.CONFIG) {
            const parsed = JSON.parse(data);
            if (parsed.config) {
              setState(prev => ({
                ...prev,
                partialConfig: parsed.config,
              }));
            }
          } else if (event === AnalyzePromptSseEvents.DONE) {
            const parsed = JSON.parse(data);
            if (parsed.config) {
              finalConfig = parsed.config;
              setState(prev => ({
                ...prev,
                partialConfig: parsed.config,
              }));
            }
          } else if (event === AnalyzePromptSseEvents.FAILED) {
            const parsed = JSON.parse(data);
            console.error('[AnalyzeStream] Failed:', parsed.error);
            // Use fallback config from error response if provided
            if (parsed.config) {
              finalConfig = parsed.config;
            }
          }
        } catch (parseErr) {
          console.error('[AnalyzeStream] Parse error:', parseErr);
        }
      };

      // Read stream
      while (true) {
        if (abortController.signal.aborted) {
          break;
        }

        const { done, value } = await reader.read();
        if (done) {
          break;
        }

        buffer += decoder.decode(value, { stream: true });

        // Parse SSE format
        const lines = buffer.split('\n');
        buffer = lines.pop() ?? ''; // Keep incomplete line in buffer

        for (const line of lines) {
          if (line.startsWith('event: ')) {
            currentEvent = line.slice(7).trim();
          } else if (line.startsWith('data: ')) {
            currentData = line.slice(6);
          } else if (line === '' && currentEvent && currentData) {
            processEvent(currentEvent, currentData);
            currentEvent = '';
            currentData = '';
          }
        }
      }

      setState(prev => ({
        ...prev,
        isStreaming: false,
      }));

      return finalConfig ?? AUTO_MODE_FALLBACK_CONFIG;
    } catch (err) {
      if (abortController.signal.aborted) {
        setState(prev => ({
          ...prev,
          isStreaming: false,
        }));
        return null;
      }

      const error = err instanceof Error ? err : new Error('Stream failed');
      console.error('[AnalyzeStream] Error:', error);

      setState({
        error,
        isStreaming: false,
        partialConfig: null,
      });

      return AUTO_MODE_FALLBACK_CONFIG;
    }
  }, [abort]);

  return {
    ...state,
    abort,
    reset,
    streamConfig,
  };
}
