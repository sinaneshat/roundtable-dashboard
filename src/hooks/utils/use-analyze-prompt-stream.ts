'use client';

/**
 * useAnalyzePromptStream - SSE Streaming Hook for Auto Mode Config Analysis
 *
 * Streams configuration recommendations from the analyze endpoint.
 * Updates partial configs in real-time as they're generated by AI.
 *
 * @example
 * const { streamConfig, isStreaming, error, partialConfig } = useAnalyzePromptStream();
 *
 * const handleSubmit = async () => {
 *   const finalConfig = await streamConfig(prompt);
 *   // Apply finalConfig to store
 * };
 */

import { useCallback, useRef, useState } from 'react';

import { AnalyzePromptSseEvents, DEFAULT_CHAT_MODE, ModelIds } from '@/api/core/enums';
import type { AnalyzePromptPayload } from '@/api/routes/chat/schema';
import { analyzePromptStreamService } from '@/services/api';

type AnalyzePromptStreamState = {
  isStreaming: boolean;
  error: Error | null;
  partialConfig: Partial<AnalyzePromptPayload> | null;
};

type AnalyzePromptStreamResult = AnalyzePromptStreamState & {
  streamConfig: (prompt: string) => Promise<AnalyzePromptPayload | null>;
  abort: () => void;
  reset: () => void;
};

// Fallback config if streaming fails
const FALLBACK_CONFIG: AnalyzePromptPayload = {
  participants: [{ modelId: ModelIds.GOOGLE_GEMINI_2_5_FLASH, role: null }],
  mode: DEFAULT_CHAT_MODE,
  enableWebSearch: false,
};

export function useAnalyzePromptStream(): AnalyzePromptStreamResult {
  const [state, setState] = useState<AnalyzePromptStreamState>({
    isStreaming: false,
    error: null,
    partialConfig: null,
  });

  const abortControllerRef = useRef<AbortController | null>(null);

  const abort = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
      abortControllerRef.current = null;
    }
  }, []);

  const reset = useCallback(() => {
    abort();
    setState({
      isStreaming: false,
      error: null,
      partialConfig: null,
    });
  }, [abort]);

  const streamConfig = useCallback(async (prompt: string): Promise<AnalyzePromptPayload | null> => {
    // Abort any existing stream
    abort();

    const abortController = new AbortController();
    abortControllerRef.current = abortController;

    setState({
      isStreaming: true,
      error: null,
      partialConfig: null,
    });

    try {
      const response = await analyzePromptStreamService({
        json: { prompt },
      });

      if (!response.ok) {
        throw new Error(`Analysis failed: ${response.statusText}`);
      }

      const reader = response.body?.getReader();
      const decoder = new TextDecoder();

      if (!reader) {
        throw new Error('No response body');
      }

      let buffer = '';
      let currentEvent = '';
      let currentData = '';
      let finalConfig: AnalyzePromptPayload | null = null;

      const processEvent = (event: string, data: string) => {
        try {
          if (event === AnalyzePromptSseEvents.START) {
            // Stream started - nothing to do
          } else if (event === AnalyzePromptSseEvents.CONFIG) {
            const parsed = JSON.parse(data);
            if (parsed.config) {
              setState(prev => ({
                ...prev,
                partialConfig: parsed.config,
              }));
            }
          } else if (event === AnalyzePromptSseEvents.DONE) {
            const parsed = JSON.parse(data);
            if (parsed.config) {
              finalConfig = parsed.config;
              setState(prev => ({
                ...prev,
                partialConfig: parsed.config,
              }));
            }
          } else if (event === AnalyzePromptSseEvents.FAILED) {
            const parsed = JSON.parse(data);
            console.error('[AnalyzeStream] Failed:', parsed.error);
            // Use fallback config from error response if provided
            if (parsed.config) {
              finalConfig = parsed.config;
            }
          }
        } catch (parseErr) {
          console.error('[AnalyzeStream] Parse error:', parseErr);
        }
      };

      // Read stream
      while (true) {
        if (abortController.signal.aborted) {
          break;
        }

        const { done, value } = await reader.read();
        if (done)
          break;

        buffer += decoder.decode(value, { stream: true });

        // Parse SSE format
        const lines = buffer.split('\n');
        buffer = lines.pop() ?? ''; // Keep incomplete line in buffer

        for (const line of lines) {
          if (line.startsWith('event: ')) {
            currentEvent = line.slice(7).trim();
          } else if (line.startsWith('data: ')) {
            currentData = line.slice(6);
          } else if (line === '' && currentEvent && currentData) {
            processEvent(currentEvent, currentData);
            currentEvent = '';
            currentData = '';
          }
        }
      }

      setState(prev => ({
        ...prev,
        isStreaming: false,
      }));

      return finalConfig ?? FALLBACK_CONFIG;
    } catch (err) {
      if (abortController.signal.aborted) {
        setState(prev => ({
          ...prev,
          isStreaming: false,
        }));
        return null;
      }

      const error = err instanceof Error ? err : new Error('Stream failed');
      console.error('[AnalyzeStream] Error:', error);

      setState({
        isStreaming: false,
        error,
        partialConfig: null,
      });

      return FALLBACK_CONFIG;
    }
  }, [abort]);

  return {
    ...state,
    streamConfig,
    abort,
    reset,
  };
}
