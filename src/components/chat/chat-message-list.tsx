'use client';
import type { UIMessage } from 'ai';
import Image from 'next/image';
import { useTranslations } from 'next-intl';
import { memo, useMemo } from 'react';

import type { ChatParticipant } from '@/api/routes/chat/schema';
import { canAccessModelByPricing } from '@/api/services/product-logic.service';
import { Message, MessageAvatar, MessageContent } from '@/components/ai-elements/message';
import { Response } from '@/components/ai-elements/response';
import { ModelMessageCard } from '@/components/chat/model-message-card';
import { useModelsQuery } from '@/hooks/queries/models';
import { useUsageStatsQuery } from '@/hooks/queries/usage';
import type { MessagePart, MessageStatus } from '@/lib/schemas/message-schemas';
import { getAvatarPropsFromModelId } from '@/lib/utils/ai-display';
import { debugLog } from '@/lib/utils/debug-logger';
import { getMessageMetadata } from '@/lib/utils/message-transforms';

const EMPTY_PARTICIPANTS: ChatParticipant[] = [];

/**
 * AI SDK v5 Pattern: Determine participant info from message metadata
 *
 * Messages flow through 3 states:
 * 1. Streaming (no metadata yet) - use current participant index
 * 2. Complete (has model metadata) - use saved metadata only
 * 3. Error (has error metadata) - use saved metadata or fallback
 *
 * CRITICAL: Messages are complete once they have metadata.model set by onFinish
 * The AI SDK adds metadata during onFinish callback, AFTER streaming completes.
 * We check for metadata.model to determine if a message has been finalized.
 */
function getParticipantInfoForMessage({
  message,
  messageIndex,
  totalMessages,
  isGlobalStreaming,
  currentParticipantIndex,
  participants,
  currentStreamingParticipant,
}: {
  message: UIMessage;
  messageIndex: number;
  totalMessages: number;
  isGlobalStreaming: boolean;
  currentParticipantIndex: number;
  participants: ChatParticipant[];
  currentStreamingParticipant: ChatParticipant | null;
}): {
  participantIndex: number;
  modelId: string | undefined;
  role: string | null;
  isStreaming: boolean;
} {
  const metadata = getMessageMetadata(message.metadata);

  // AI SDK v5 Pattern: A message is complete once it has model metadata
  // The onFinish callback in useMultiParticipantChat adds metadata.model via mergeParticipantMetadata
  // This happens AFTER streaming completes and BEFORE the next participant starts (via flushSync)
  const isComplete = !!metadata?.model;

  debugLog.participantInfo('getParticipantInfo: Evaluating message', {
    messageId: message.id,
    messageIndex,
    messageRole: message.role,
    isComplete,
    hasMetadata: !!metadata,
    metadataModel: metadata?.model,
    metadataParticipantId: metadata?.participantId,
    metadataParticipantIndex: metadata?.participantIndex,
    currentParticipantIndex,
    isGlobalStreaming,
    rawMetadata: message.metadata,
  });

  if (isComplete) {
    // ✅ CRITICAL FIX: Use saved metadata for completed messages
    // Once a message has metadata.model, it should NEVER revert to streaming state
    // This prevents the first participant's message from "disappearing" when the second starts
    const result = {
      participantIndex: metadata?.participantIndex ?? 0,
      modelId: metadata.model,
      role: metadata.participantRole || null,
      isStreaming: false,
    };

    debugLog.participantInfo('getParticipantInfo: Using saved metadata (complete)', {
      ...result,
      messageId: message.id,
      savedParticipantId: metadata?.participantId,
    });
    return result;
  }

  // AI SDK v5 Pattern: Only messages WITHOUT metadata.model can be streaming
  // This means the message is currently being generated by the AI SDK
  const isLastMessage = messageIndex === totalMessages - 1;
  const isThisMessageStreaming = !isComplete && isGlobalStreaming && isLastMessage && message.role === 'assistant';

  if (isThisMessageStreaming) {
    // Use current participant for actively streaming message
    const participant = participants[currentParticipantIndex] || currentStreamingParticipant;
    return {
      participantIndex: currentParticipantIndex,
      modelId: participant?.modelId || metadata?.model,
      role: participant?.role || metadata?.participantRole || null,
      isStreaming: true,
    };
  }

  // Fallback for messages that haven't finished yet but aren't actively streaming
  // This can happen briefly during state transitions
  return {
    participantIndex: metadata?.participantIndex ?? currentParticipantIndex,
    modelId: metadata?.model,
    role: metadata?.participantRole || null,
    isStreaming: false,
  };
}

type ChatMessageListProps = {
  messages: UIMessage[];
  user?: {
    name: string;
    image: string | null;
  } | null;
  participants?: ChatParticipant[];
  hideMetadata?: boolean;
  isLoading?: boolean;
  isStreaming?: boolean;
  currentStreamingParticipant?: ChatParticipant | null;
  currentParticipantIndex?: number;
  userAvatar?: { src: string; name: string };
};
export const ChatMessageList = memo(
  ({
    messages,
    user = null,
    participants = EMPTY_PARTICIPANTS,
    hideMetadata = false,
    isLoading: _isLoading = false,
    isStreaming = false,
    currentStreamingParticipant = null,
    currentParticipantIndex = 0,
    userAvatar,
  }: ChatMessageListProps) => {
    debugLog.messageRender('ChatMessageList: Rendering', {
      messageCount: messages.length,
      isStreaming,
      currentParticipantIndex,
    });
    const t = useTranslations();
    const { data: modelsData } = useModelsQuery();
    const { data: usageData } = useUsageStatsQuery();
    const allModels = modelsData?.data?.items || [];
    const userTier = usageData?.data?.subscription?.tier || 'free';
    const userInfo = user || { name: 'User', image: null };
    const userAvatarSrc = userAvatar?.src || userInfo.image || '/avatars/user.png';
    const userAvatarName = userAvatar?.name || userInfo.name;

    // ✅ DEDUPLICATION: Focus on user messages to prevent duplicate triggers
    // According to FLOW_DOCUMENTATION: One user message → All participants respond → One analysis
    // Also filters out participant trigger messages (created when orchestrating sequential responses)
    const deduplicatedMessages = useMemo(() => {
      const seenRounds = new Map<number, UIMessage>(); // roundNumber -> first user message
      const result: UIMessage[] = [];

      for (const message of messages) {
      // For user messages, deduplicate by round number and filter participant triggers
        if (message.role === 'user') {
          const metadata = message.metadata as Record<string, unknown> | undefined;
          const roundNumber = metadata?.roundNumber as number | undefined;
          const isParticipantTrigger = metadata?.isParticipantTrigger === true;

          // Skip participant trigger duplicates completely
          if (isParticipantTrigger) {
            continue;
          }

          // For regular user messages, keep only first per round
          if (roundNumber !== undefined) {
            if (!seenRounds.has(roundNumber)) {
              seenRounds.set(roundNumber, message);
              result.push(message);
            }
          } else {
          // Messages without round numbers (shouldn't happen, but keep them)
            result.push(message);
          }
        } else {
        // For assistant/system messages, keep all (participants can have multiple messages)
          result.push(message);
        }
      }

      return result;
    }, [messages]);

    // Create safe React keys even with potential duplicate IDs
    const seenIds = new Set<string>();
    const keyForMessage = (message: UIMessage, index: number): string => {
      if (seenIds.has(message.id)) {
      // Fallback key for duplicate IDs
        return `${message.id}-${index}`;
      }
      seenIds.add(message.id);
      return message.id;
    };

    // Memoize participant info per message to prevent recalculation on every render
    // This is critical because getParticipantInfoForMessage is expensive and runs for ALL messages
    const messagesWithParticipantInfo = useMemo(() => {
      return deduplicatedMessages.map((message, index) => {
        if (message.role === 'user') {
          return { message, index, participantInfo: null };
        }

        const participantInfo = getParticipantInfoForMessage({
          message,
          messageIndex: index,
          totalMessages: deduplicatedMessages.length,
          isGlobalStreaming: isStreaming,
          currentParticipantIndex,
          participants,
          currentStreamingParticipant,
        });

        return { message, index, participantInfo };
      });
    }, [deduplicatedMessages, isStreaming, currentParticipantIndex, participants, currentStreamingParticipant]);

    return (
      <>
        {messagesWithParticipantInfo.map(({ message, index, participantInfo }) => {
          const messageKey = keyForMessage(message, index);
          if (message.role === 'user') {
            return (
              <Message from="user" key={messageKey}>
                <MessageContent>
                  {message.parts.map((part) => {
                    if (part.type === 'text') {
                      return (
                        <Response key={`${message.id}-text-${part.text.substring(0, 20)}`}>
                          {part.text}
                        </Response>
                      );
                    }
                    if (part.type === 'file' && part.mediaType?.startsWith('image/')) {
                      return (
                        <div key={`${message.id}-image-${part.url}`} className="my-2">
                          <Image
                            src={part.url}
                            alt={part.filename || 'Attachment'}
                            className="max-w-full rounded-lg border border-border"
                            style={{ maxHeight: '400px' }}
                            width={800}
                            height={400}
                            unoptimized
                          />
                          {part.filename && (
                            <p className="mt-1 text-xs text-muted-foreground">{part.filename}</p>
                          )}
                        </div>
                      );
                    }
                    if (part.type === 'file') {
                      return (
                        <div key={`${message.id}-file-${part.filename || part.url}`} className="my-2 p-3 border border-border rounded-lg">
                          <div className="flex items-center gap-2">
                            <div className="flex-1">
                              <p className="text-sm font-medium">{part.filename || 'File'}</p>
                              {part.mediaType && (
                                <p className="text-xs text-muted-foreground">{part.mediaType}</p>
                              )}
                            </div>
                            <a
                              href={part.url}
                              download={part.filename}
                              className="text-xs text-primary hover:underline"
                            >
                              {t('actions.download')}
                            </a>
                          </div>
                        </div>
                      );
                    }
                    return null;
                  })}
                </MessageContent>
                <MessageAvatar
                  src={userAvatarSrc}
                  name={userAvatarName}
                />
              </Message>
            );
          }

          // AI SDK v5 Pattern: Use pre-calculated participant info from memoized array
          // This prevents recalculating participant info on every render
          if (!participantInfo) {
            return null;
          }

          const metadata = getMessageMetadata(message.metadata);
          const avatarProps = getAvatarPropsFromModelId(
            message.role === 'system' ? 'assistant' : message.role,
            participantInfo.modelId,
            userInfo.image,
            userInfo.name,
          );
          const model = participantInfo.modelId ? allModels.find(m => m.id === participantInfo.modelId) : undefined;
          const isAccessible = model ? canAccessModelByPricing(userTier, model) : true;
          const hasError = metadata?.hasError === true || !!metadata?.error;

          const hasTextContent = message.parts.some(p => p.type === 'text' && p.text.trim().length > 0);
          const hasToolCalls = message.parts.some(p => p.type === 'tool-call');
          const hasAnyContent = hasTextContent || hasToolCalls;

          const messageStatus: MessageStatus = hasError
            ? 'error'
            : participantInfo.isStreaming && !hasAnyContent
              ? 'thinking'
              : participantInfo.isStreaming
                ? 'streaming'
                : 'completed';
          const filteredParts = message.parts
            .filter(p =>
              p.type === 'text'
              || p.type === 'reasoning'
              || p.type === 'tool-call'
              || p.type === 'tool-result',
            )
            .map(p => p as MessagePart);
          const sourceParts = message.parts.filter(p =>
            'type' in p && (p.type === 'source-url' || p.type === 'source-document'),
          );
          return (
            <div key={messageKey}>
              <ModelMessageCard
                messageId={message.id}
                model={model}
                role={participantInfo.role || ''}
                participantIndex={participantInfo.participantIndex}
                status={messageStatus}
                parts={filteredParts}
                avatarSrc={avatarProps.src}
                avatarName={avatarProps.name}
                metadata={hideMetadata ? null : (metadata ?? null)}
                isAccessible={isAccessible}
              />
              {sourceParts.length > 0 && (
                <div className="mt-2 ml-12 space-y-1">
                  <p className="text-xs font-medium text-muted-foreground">{t('sources.title')}</p>
                  <div className="space-y-1">
                    {sourceParts.map((sourcePart) => {
                      if ('type' in sourcePart && sourcePart.type === 'source-url' && 'url' in sourcePart) {
                        return (
                          <div key={`${message.id}-source-${sourcePart.url}`} className="text-xs">
                            <a
                              href={sourcePart.url as string}
                              target="_blank"
                              rel="noopener noreferrer"
                              className="text-primary hover:underline flex items-center gap-1"
                            >
                              <span>{('title' in sourcePart && sourcePart.title) || sourcePart.url}</span>
                              <svg
                                className="w-3 h-3"
                                fill="none"
                                stroke="currentColor"
                                viewBox="0 0 24 24"
                              >
                                <path
                                  strokeLinecap="round"
                                  strokeLinejoin="round"
                                  strokeWidth={2}
                                  d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14"
                                />
                              </svg>
                            </a>
                          </div>
                        );
                      }
                      return null;
                    })}
                  </div>
                </div>
              )}
            </div>
          );
        })}
      </>
    );
  },
  // Custom comparison function to optimize re-renders
  // Only re-render if critical props actually change
  (prevProps, nextProps) => {
    // Always re-render if streaming state changes
    if (prevProps.isStreaming !== nextProps.isStreaming) {
      debugLog.messageRender('ChatMessageList: Re-render due to isStreaming change', {
        prev: prevProps.isStreaming,
        next: nextProps.isStreaming,
      });
      return false;
    }

    // Always re-render if messages array reference changes OR content changes
    if (
      prevProps.messages !== nextProps.messages
      || prevProps.messages.length !== nextProps.messages.length
    ) {
      debugLog.messageRender('ChatMessageList: Re-render due to messages change', {
        prevLength: prevProps.messages.length,
        nextLength: nextProps.messages.length,
        sameReference: prevProps.messages === nextProps.messages,
      });
      return false;
    }

    // Only re-render if currentParticipantIndex changes AND we're currently streaming
    // If not streaming, completed messages don't care about currentParticipantIndex
    if (
      prevProps.currentParticipantIndex !== nextProps.currentParticipantIndex
      && nextProps.isStreaming
    ) {
      debugLog.messageRender('ChatMessageList: Re-render due to participant index change during streaming', {
        prev: prevProps.currentParticipantIndex,
        next: nextProps.currentParticipantIndex,
      });
      return false;
    }

    // Re-render if participants reference changes (shouldn't happen often)
    if (prevProps.participants !== nextProps.participants) {
      debugLog.messageRender('ChatMessageList: Re-render due to participants change', {
        prevLength: prevProps.participants?.length ?? 0,
        nextLength: nextProps.participants?.length ?? 0,
      });
      return false;
    }

    // Re-render if currentStreamingParticipant changes AND we're streaming
    if (
      prevProps.currentStreamingParticipant !== nextProps.currentStreamingParticipant
      && nextProps.isStreaming
    ) {
      debugLog.messageRender('ChatMessageList: Re-render due to streaming participant change', {
        prevModel: prevProps.currentStreamingParticipant?.modelId,
        nextModel: nextProps.currentStreamingParticipant?.modelId,
      });
      return false;
    }

    // Skip re-render - no meaningful changes
    debugLog.messageRender('ChatMessageList: Skipping re-render (no meaningful changes)', {
      currentParticipantIndexChanged: prevProps.currentParticipantIndex !== nextProps.currentParticipantIndex,
      isStreaming: nextProps.isStreaming,
    });
    return true;
  },
);
