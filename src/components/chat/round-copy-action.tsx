'use client';

import type { UIMessage } from 'ai';
import { Check, Copy } from 'lucide-react';
import { useTranslations } from 'next-intl';
import { memo, useCallback, useState } from 'react';

import { MessagePartTypes, MessageRoles } from '@/api/core/enums';
import type { ChatParticipant } from '@/api/routes/chat/schema';
import { Action } from '@/components/ai-elements/actions';
import { toastManager } from '@/lib/toast';
import { getAssistantMetadata } from '@/lib/utils/metadata';

type RoundCopyActionProps = {
  messages: UIMessage[];
  participants: ChatParticipant[];
  roundNumber: number;
  threadTitle?: string;
  summaryText?: string;
  className?: string;
};

/**
 * Gets participant for a message from metadata
 */
function getParticipantFromMessage(
  message: UIMessage,
  participants: ChatParticipant[],
): ChatParticipant | undefined {
  const metadata = getAssistantMetadata(message.metadata);
  if (metadata?.participantId) {
    return participants.find(p => p.id === metadata.participantId);
  }
  return undefined;
}

/**
 * Gets display name for a participant
 */
function getParticipantDisplayName(participant?: ChatParticipant): string {
  if (!participant)
    return 'Assistant';
  if (participant.role)
    return participant.role;
  // Extract model name from modelId (e.g., "anthropic/claude-3.5-sonnet" -> "Claude 3.5 Sonnet")
  const modelName = participant.modelId.split('/').pop() || participant.modelId;
  return modelName
    .split('-')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
}

/**
 * Extracts text content from a UIMessage's parts
 */
function getMessageTextContent(message: UIMessage): string {
  if (!message.parts || message.parts.length === 0) {
    return '';
  }

  return message.parts
    .filter(part => part.type === MessagePartTypes.TEXT && 'text' in part)
    .map(part => (part as { type: 'text'; text: string }).text)
    .join('\n\n');
}

/**
 * Formats round messages as markdown
 */
function formatRoundAsMarkdown(
  messages: UIMessage[],
  participants: ChatParticipant[],
  roundNumber: number,
  threadTitle?: string,
  summaryText?: string,
): string {
  const lines: string[] = [];
  const timestamp = new Date().toISOString().split('T')[0];

  // Header
  if (threadTitle) {
    lines.push(`# ${threadTitle}`);
    lines.push('');
  }
  lines.push(`## Round ${roundNumber}`);
  lines.push('');
  lines.push(`*Exported on ${timestamp}*`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Group messages by role for better formatting
  for (const message of messages) {
    const content = getMessageTextContent(message);
    if (!content.trim())
      continue;

    if (message.role === MessageRoles.USER) {
      lines.push('### User');
      lines.push('');
      lines.push(content);
      lines.push('');
    } else if (message.role === MessageRoles.ASSISTANT) {
      const participant = getParticipantFromMessage(message, participants);
      const displayName = getParticipantDisplayName(participant);
      lines.push(`### ${displayName}`);
      if (participant?.modelId) {
        lines.push(`*Model: ${participant.modelId}*`);
      }
      lines.push('');
      lines.push(content);
      lines.push('');
    }
  }

  // Include summary if provided
  if (summaryText) {
    lines.push('---');
    lines.push('');
    lines.push('### Council Moderator Summary');
    lines.push('');
    lines.push(summaryText);
    lines.push('');
  }

  lines.push('---');
  lines.push('');
  lines.push('*Generated by Roundtable*');

  return lines.join('\n');
}

/**
 * Copies content to clipboard
 */
async function copyToClipboard(content: string): Promise<boolean> {
  try {
    await navigator.clipboard.writeText(content);
    return true;
  } catch {
    return false;
  }
}

function RoundCopyActionComponent({
  messages,
  participants,
  roundNumber,
  threadTitle,
  summaryText,
  className,
}: RoundCopyActionProps) {
  const t = useTranslations('chat.roundActions');
  const [copied, setCopied] = useState(false);

  const handleCopy = useCallback(async () => {
    const markdown = formatRoundAsMarkdown(messages, participants, roundNumber, threadTitle, summaryText);
    const success = await copyToClipboard(markdown);

    if (success) {
      setCopied(true);
      toastManager.success(t('copySuccess'), t('copySuccessDescription'));
      setTimeout(() => setCopied(false), 2000);
    } else {
      toastManager.error(t('copyError'), t('copyErrorDescription'));
    }
  }, [messages, participants, roundNumber, threadTitle, summaryText, t]);

  return (
    <Action
      tooltip={t('copyRound')}
      label={t('copyRound')}
      onClick={handleCopy}
      className={className}
    >
      {copied ? <Check className="size-3" /> : <Copy className="size-3" />}
    </Action>
  );
}

export const RoundCopyAction = memo(
  RoundCopyActionComponent,
  (prevProps, nextProps) => {
    return (
      prevProps.roundNumber === nextProps.roundNumber
      && prevProps.messages.length === nextProps.messages.length
      && prevProps.threadTitle === nextProps.threadTitle
      && prevProps.summaryText === nextProps.summaryText
      && prevProps.className === nextProps.className
    );
  },
);
