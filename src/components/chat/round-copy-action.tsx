'use client';

import type { UIMessage } from 'ai';
import { useTranslations } from 'next-intl';
import { memo, useCallback, useState } from 'react';

import { MessageRoles } from '@/api/core/enums';
import type { ChatParticipant } from '@/api/routes/chat/schema';
import { Action } from '@/components/ai-elements/actions';
import { Icons } from '@/components/icons';
import { toastManager } from '@/lib/toast';
import { copyToClipboard, getAssistantMetadata, isTextPart } from '@/lib/utils';

type RoundCopyActionProps = {
  messages: UIMessage[];
  participants: ChatParticipant[];
  roundNumber: number;
  threadTitle?: string;
  moderatorText?: string;
  className?: string;
};

function getParticipantFromMessage(
  message: UIMessage,
  participants: ChatParticipant[],
): ChatParticipant | undefined {
  const metadata = getAssistantMetadata(message.metadata);
  if (metadata?.participantId) {
    return participants.find(p => p.id === metadata.participantId);
  }
  return undefined;
}

function getParticipantDisplayName(participant: ChatParticipant | undefined): string {
  if (!participant)
    return 'Assistant';
  if (participant.role)
    return participant.role;
  const modelName = participant.modelId.split('/').pop() ?? participant.modelId;
  return modelName.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
}

function getMessageTextContent(message: UIMessage): string {
  if (!message.parts || message.parts.length === 0) {
    return '';
  }
  return message.parts.filter(isTextPart).map(part => part.text).join('\n\n');
}

function formatRoundAsMarkdown(
  messages: UIMessage[],
  participants: ChatParticipant[],
  roundNumber: number,
  threadTitle?: string,
  moderatorText?: string,
): string {
  const lines: string[] = [];
  const timestamp = new Date().toISOString().split('T')[0];

  if (threadTitle) {
    lines.push(`# ${threadTitle}`);
    lines.push('');
  }
  lines.push(`## Round ${roundNumber}`);
  lines.push('');
  lines.push(`*Exported on ${timestamp}*`);
  lines.push('');
  lines.push('---');
  lines.push('');

  for (const message of messages) {
    const content = getMessageTextContent(message);
    if (!content.trim())
      continue;

    if (message.role === MessageRoles.USER) {
      lines.push('### User');
      lines.push('');
      lines.push(content);
      lines.push('');
    } else if (message.role === MessageRoles.ASSISTANT) {
      const participant = getParticipantFromMessage(message, participants);
      const displayName = getParticipantDisplayName(participant);
      lines.push(`### ${displayName}`);
      if (participant?.modelId) {
        lines.push(`*Model: ${participant.modelId}*`);
      }
      lines.push('');
      lines.push(content);
      lines.push('');
    }
  }

  if (moderatorText) {
    lines.push('---');
    lines.push('');
    lines.push('### Moderator');
    lines.push('');
    lines.push(moderatorText);
    lines.push('');
  }

  lines.push('---');
  lines.push('');
  lines.push('*Generated by Roundtable*');

  return lines.join('\n');
}

function RoundCopyActionComponent({
  messages,
  participants,
  roundNumber,
  threadTitle,
  moderatorText,
  className,
}: RoundCopyActionProps) {
  const t = useTranslations('chat.roundActions');
  const [copied, setCopied] = useState(false);

  const handleCopy = useCallback(async () => {
    const markdown = formatRoundAsMarkdown(messages, participants, roundNumber, threadTitle, moderatorText);
    const success = await copyToClipboard(markdown);

    if (success) {
      setCopied(true);
      toastManager.success(t('copySuccess'), t('copySuccessDescription'));
      setTimeout(() => setCopied(false), 2000);
    } else {
      toastManager.error(t('copyError'), t('copyErrorDescription'));
    }
  }, [messages, participants, roundNumber, threadTitle, moderatorText, t]);

  return (
    <Action
      tooltip={t('copyRound')}
      label={t('copyRound')}
      onClick={handleCopy}
      className={className}
    >
      {copied ? <Icons.check className="size-5" /> : <Icons.squareStack className="size-5" />}
    </Action>
  );
}

export const RoundCopyAction = memo(
  RoundCopyActionComponent,
  (prevProps, nextProps) => {
    return (
      prevProps.roundNumber === nextProps.roundNumber
      && prevProps.messages.length === nextProps.messages.length
      && prevProps.threadTitle === nextProps.threadTitle
      && prevProps.moderatorText === nextProps.moderatorText
      && prevProps.className === nextProps.className
    );
  },
);

RoundCopyAction.displayName = 'RoundCopyAction';
