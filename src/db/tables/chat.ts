import { relations, sql } from 'drizzle-orm';
import { check, index, integer, sqliteTable, text, uniqueIndex } from 'drizzle-orm/sqlite-core';

import type {
  AgreementStatus,
  EvidenceStrength,
  VoteType,
} from '@/api/core/enums';
import {
  ANALYSIS_STATUSES,
  CHANGELOG_TYPES,
  CHAT_MODES,
  DEFAULT_CHAT_MODE,
  FEEDBACK_TYPES,
  MESSAGE_ROLES,
  THREAD_STATUSES,
} from '@/api/core/enums';
import type {
  DbChangelogData,
  DbCustomRoleMetadata,
  DbMessageMetadata,
  DbParticipantSettings,
  DbThreadMetadata,
} from '@/db/schemas/chat-metadata';

import { user } from './auth';
import { chatProject } from './project';
import { messageUpload } from './upload';

/**
 * Chat Threads
 * Container for multi-model conversations with configuration
 */
export const chatThread = sqliteTable('chat_thread', {
  id: text('id').primaryKey(),
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),

  // Project association (optional - threads can exist without projects)
  projectId: text('project_id')
    .references(() => chatProject.id, { onDelete: 'set null' }),

  title: text('title').notNull(),
  slug: text('slug').notNull().unique(), // SEO-friendly URL slug (e.g., "product-strategy-abc123")
  mode: text('mode', { enum: CHAT_MODES })
    .notNull()
    .default(DEFAULT_CHAT_MODE),
  status: text('status', { enum: THREAD_STATUSES })
    .notNull()
    .default('active'),
  isFavorite: integer('is_favorite', { mode: 'boolean' })
    .notNull()
    .default(false), // User can mark threads as favorites
  isPublic: integer('is_public', { mode: 'boolean' })
    .notNull()
    .default(false), // Public threads can be viewed without authentication
  isAiGeneratedTitle: integer('is_ai_generated_title', { mode: 'boolean' })
    .notNull()
    .default(false), // Track if title was generated by AI (vs default "New Chat")
  enableWebSearch: integer('enable_web_search', { mode: 'boolean' })
    .notNull()
    .default(false), // Allow participants to browse web for information
  // ✅ TYPE-SAFE: Strictly typed metadata using discriminated union schema
  metadata: text('metadata', { mode: 'json' }).$type<DbThreadMetadata>(),
  // Optimistic locking - prevents lost updates in concurrent modifications
  version: integer('version').notNull().default(1),
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
  lastMessageAt: integer('last_message_at', { mode: 'timestamp_ms' }),
}, table => [
  index('chat_thread_user_idx').on(table.userId),
  index('chat_thread_project_idx').on(table.projectId),
  index('chat_thread_status_idx').on(table.status),
  index('chat_thread_updated_idx').on(table.updatedAt),
  index('chat_thread_slug_idx').on(table.slug), // Fast lookups by slug for public sharing
  index('chat_thread_favorite_idx').on(table.isFavorite),
  index('chat_thread_public_idx').on(table.isPublic),
]);

/**
 * Custom Roles
 * User-defined role templates with system prompts that can be reused
 * Examples: "The Devil's Advocate", "The Fact Checker", "The Creative Ideator"
 * Defined before chatParticipant to allow forward reference
 */
export const chatCustomRole = sqliteTable('chat_custom_role', {
  id: text('id').primaryKey(),
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  name: text('name').notNull(), // e.g., "The Devil's Advocate"
  description: text('description'), // Brief description of the role
  systemPrompt: text('system_prompt').notNull(), // The actual prompt that defines the role behavior
  // ✅ TYPE-SAFE: Strictly typed metadata for custom roles
  metadata: text('metadata', { mode: 'json' }).$type<DbCustomRoleMetadata>(),
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
}, table => [
  index('chat_custom_role_user_idx').on(table.userId),
  index('chat_custom_role_name_idx').on(table.name),
]);

/**
 * Chat Participants
 * Models participating in a thread with their assigned roles
 * Can use custom role templates or inline role definitions
 */
export const chatParticipant = sqliteTable('chat_participant', {
  id: text('id').primaryKey(),
  threadId: text('thread_id')
    .notNull()
    .references(() => chatThread.id, { onDelete: 'cascade' }),
  modelId: text('model_id').notNull(), // e.g., 'anthropic/claude-sonnet-4.5', 'openai/gpt-5'
  customRoleId: text('custom_role_id')
    .references(() => chatCustomRole.id, { onDelete: 'set null' }), // Reference to saved custom role (optional)
  role: text('role'), // Optional role name (from custom role or inline) - e.g., "The Ideator", "Devil's Advocate"
  priority: integer('priority').notNull().default(0), // Order in which models respond
  isEnabled: integer('is_enabled', { mode: 'boolean' })
    .notNull()
    .default(true),
  // ✅ TYPE-SAFE: Strictly typed settings (temperature, maxTokens, systemPrompt)
  settings: text('settings', { mode: 'json' }).$type<DbParticipantSettings>(),
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
}, table => [
  // Indexes for query performance
  index('chat_participant_thread_idx').on(table.threadId),
  index('chat_participant_priority_idx').on(table.priority),
  index('chat_participant_custom_role_idx').on(table.customRoleId),

  // ============================================================================
  // DATABASE-LEVEL CONSTRAINTS (Second layer of protection)
  // ============================================================================

  // ✅ PRIORITY CONSTRAINT: Ensure priority is non-negative
  // Rationale: Priority determines response order, must be >= 0
  check('check_priority_non_negative', sql`${table.priority} >= 0`),

  // ✅ UNIQUE CONSTRAINT: Prevent duplicate participants per thread
  // BUG FIX: Without this, race conditions between PATCH and streaming handlers
  // could create multiple participants with the same modelId in one thread.
  // This is the database-level protection to ensure data integrity.
  uniqueIndex('chat_participant_thread_model_unique').on(table.threadId, table.modelId),
]);

/**
 * Chat Thread Changelog
 * Tracks configuration changes to threads (participants, mode)
 * Shows between conversation rounds when user modifies thread configuration
 *
 * ✅ EVENT-BASED ROUND TRACKING: Like messages and analysis, changelog entries
 * are tied to specific rounds. They appear BETWEEN rounds to show what changed
 * before the next user prompt was submitted.
 *
 * Example flow:
 * - Round 1: User asks question, models respond
 * - [Analysis for Round 1]
 * - User changes mode from "brainstorming" to "analyzing"
 * - User reorders participants
 * - User submits next message → CHANGELOG CREATED for Round 2
 * - [Changelog showing mode change + reordering] ← Shows BEFORE Round 2 messages
 * - Round 2: User asks question, models respond with new config
 */
export const chatThreadChangelog = sqliteTable('chat_thread_changelog', {
  id: text('id').primaryKey(),
  threadId: text('thread_id')
    .notNull()
    .references(() => chatThread.id, { onDelete: 'cascade' }),
  // ✅ ROUND TRACKING: Which round does this changelog belong to?
  // Changelog for round N appears BEFORE round N messages (showing what changed)
  // ✅ 0-BASED: First round is 0
  roundNumber: integer('round_number')
    .notNull()
    .default(0), // ✅ 0-BASED: Default to round 0
  changeType: text('change_type', { enum: CHANGELOG_TYPES }).notNull(),
  changeSummary: text('change_summary').notNull(), // Human-readable summary
  // ✅ TYPE-SAFE: Discriminated union by 'type' field - no escape hatches
  // Four change types: 'participant', 'participant_role', 'mode_change', 'participant_reorder'
  changeData: text('change_data', { mode: 'json' }).$type<DbChangelogData>().notNull(),
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
}, table => [
  index('chat_thread_changelog_thread_idx').on(table.threadId),
  index('chat_thread_changelog_type_idx').on(table.changeType),
  index('chat_thread_changelog_created_idx').on(table.createdAt),
  // ✅ ROUND TRACKING INDEX: Efficient queries by thread + round
  index('chat_thread_changelog_thread_round_idx').on(table.threadId, table.roundNumber),
]);

/**
 * Chat Messages
 * Individual messages in threads (user input + model responses)
 *
 * ✅ AI SDK v5 ALIGNMENT: Schema matches UIMessage format from @ai-sdk/react
 * - parts[] array stores message content (text, reasoning, tool-result, etc.)
 * - Direct mapping to/from UIMessage without transformation overhead
 * - Supports multi-part messages (text + reasoning in single message)
 *
 * Reference: https://sdk.vercel.ai/docs/ai-sdk-ui/chatbot#message-format
 */
export const chatMessage = sqliteTable('chat_message', {
  id: text('id').primaryKey(),
  threadId: text('thread_id')
    .notNull()
    .references(() => chatThread.id, { onDelete: 'cascade' }),
  participantId: text('participant_id')
    .references(() => chatParticipant.id, { onDelete: 'set null' }), // null for user messages
  role: text('role', { enum: MESSAGE_ROLES })
    .notNull()
    .default('assistant'),

  // ✅ AI SDK v5 PATTERN: Store parts[] array matching UIMessage.parts structure
  // Eliminates transformation overhead - direct pass-through to/from frontend
  // Supports: text parts, reasoning parts (Claude extended thinking), tool parts
  // Tool parts: tool-call (function invocation) and tool-result (execution result)
  //
  // ✅ ZERO-DOWNTIME MIGRATION: TypeScript-only change, existing messages still valid
  // Existing messages without tool parts continue to work without modification
  parts: text('parts', { mode: 'json' }).notNull().$type<Array<
    | { type: 'text'; text: string }
    | { type: 'reasoning'; text: string }
    | {
      type: 'tool-call';
      toolCallId: string;
      toolName: string;
      args: unknown;
    }
    | {
      type: 'tool-result';
      toolCallId: string;
      toolName: string;
      result: unknown;
      isError?: boolean;
    }
    // ✅ MULTI-MODAL: File attachments (images, PDFs) for AI model consumption
    // Reference: AI SDK v5 FilePart - https://sdk.vercel.ai/docs/ai-sdk-ui/chatbot#multi-modal-messages
    | {
      type: 'file';
      url: string;
      mediaType: string;
      filename?: string;
    }
    // ✅ AI SDK v5 STREAMING: Step start marker for streaming lifecycle
    | { type: 'step-start' }
  >>(),

  // ✅ ROUND TRACKING: Event-based round number for reliable analysis placement
  // Round = User message + all participant responses
  // Eliminates fragile date/time calculations on frontend
  // ✅ 0-BASED: First round is 0
  roundNumber: integer('round_number')
    .notNull()
    .default(0), // ✅ 0-BASED: Default to round 0

  // ✅ TOOL SUPPORT: Store tool calls made by the model (separate from tool results in parts[])
  toolCalls: text('tool_calls', { mode: 'json' }).$type<Array<{
    id: string;
    type: string;
    function: {
      name: string;
      arguments: string;
    };
  }>>(),

  // ✅ TYPE-SAFE: Discriminated union by 'role' field - strictly validated metadata
  // Three message types: user, assistant/participant, pre-search/system
  // Each type has different required fields enforced by discriminated union
  metadata: text('metadata', { mode: 'json' }).$type<DbMessageMetadata>(),

  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
}, table => [
  index('chat_message_thread_idx').on(table.threadId),
  index('chat_message_created_idx').on(table.createdAt),
  index('chat_message_participant_idx').on(table.participantId),
  // ✅ Composite index for efficient message filtering by role
  index('chat_message_role_idx').on(table.role),
  // ✅ Composite index for paginated message queries (thread + sort)
  index('chat_message_thread_created_idx').on(table.threadId, table.createdAt),
  // ✅ ROUND TRACKING INDEX: Efficient queries by thread + round for analysis placement
  index('chat_message_thread_round_idx').on(table.threadId, table.roundNumber),
]);

/**
 * Moderator Round Analysis
 * Stores AI-generated analysis results for each conversation round
 * Allows users to view past analyses when revisiting threads
 */
export const chatModeratorAnalysis = sqliteTable('chat_moderator_analysis', {
  id: text('id').primaryKey(),
  threadId: text('thread_id')
    .notNull()
    .references(() => chatThread.id, { onDelete: 'cascade' }),
  roundNumber: integer('round_number').notNull(), // ✅ 0-BASED: First round is 0
  mode: text('mode', { enum: CHAT_MODES }).notNull(), // Mode when analysis was performed
  userQuestion: text('user_question').notNull(), // The user's question/prompt for this round
  // ✅ CRITICAL: Status field for idempotency and state tracking
  // Prevents duplicate analysis generation on page refresh
  status: text('status', { enum: ANALYSIS_STATUSES })
    .notNull()
    .default('pending'), // pending -> streaming -> complete/failed
  // Store the full analysis as JSON - Multi-AI Deliberation Framework
  // ✅ NULLABLE: Only populated once streaming completes successfully
  // ✅ BREAKING CHANGE: Complete redesign for collaborative AI analysis
  analysisData: text('analysis_data', { mode: 'json' }).$type<{
    // Key Insights & Recommendations
    summary: string;
    recommendations: Array<{
      title: string;
      description: string;
      suggestedModels?: string[];
      suggestedRoles?: string[];
      suggestedMode?: string;
    }>;

    // Contributor Perspectives
    contributorPerspectives: Array<{
      participantIndex: number;
      role: string | null; // ✅ FIX: Participants can have no custom role
      modelId: string;
      modelName: string;
      scorecard: {
        logic: number;
        riskAwareness: number;
        creativity: number;
        evidence: number;
        consensus?: number;
      };
      stance: string;
      evidence: string[];
      vote: VoteType | null; // ✅ FIX: Allow null vote for insufficient content (AI may return null when vote can't be determined)
    }>;

    // Consensus Analysis
    consensusAnalysis: {
      alignmentSummary: {
        totalClaims: number;
        majorAlignment: number;
        contestedClaims: number;
        contestedClaimsList: Array<{
          claim: string;
          status: 'contested';
        }>;
      };
      agreementHeatmap: Array<{
        claim: string;
        perspectives: Record<string, AgreementStatus>;
      }>;
      argumentStrengthProfile: Record<string, {
        logic: number;
        evidence: number;
        riskAwareness: number;
        consensus: number;
        creativity: number;
      }>;
    };

    // Evidence & Reasoning
    evidenceAndReasoning: {
      reasoningThreads: Array<{
        claim: string;
        synthesis: string;
      }>;
      evidenceCoverage: Array<{
        claim: string;
        strength: EvidenceStrength;
        percentage: number;
      }>;
    };

    // Explore Alternatives
    alternatives: Array<{
      scenario: string;
      confidence: number;
    }>;

    // Round Summary
    roundSummary: {
      participation: {
        approved: number;
        cautioned: number;
        rejected: number;
      };
      keyThemes: string;
      unresolvedQuestions: string[];
      generated: string;
    };
  }>(),
  // Store participant message IDs that were analyzed
  participantMessageIds: text('participant_message_ids', { mode: 'json' }).notNull().$type<string[]>(),
  // ✅ Error tracking for failed analyses
  errorMessage: text('error_message'),
  // ✅ Completion timestamp (null until status = 'complete')
  completedAt: integer('completed_at', { mode: 'timestamp_ms' }),
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
}, table => [
  index('chat_moderator_analysis_thread_idx').on(table.threadId),
  index('chat_moderator_analysis_round_idx').on(table.threadId, table.roundNumber),
  index('chat_moderator_analysis_created_idx').on(table.createdAt),
  // ✅ NEW: Index on status for efficient querying of in-progress analyses
  index('chat_moderator_analysis_status_idx').on(table.status),
]);

/**
 * Chat Round Feedback
 * Stores user feedback (like/dislike) for each round of conversation
 */
export const chatRoundFeedback = sqliteTable('chat_round_feedback', {
  id: text('id').primaryKey(),
  threadId: text('thread_id')
    .notNull()
    .references(() => chatThread.id, { onDelete: 'cascade' }),
  userId: text('user_id')
    .notNull()
    .references(() => user.id, { onDelete: 'cascade' }),
  roundNumber: integer('round_number').notNull(), // ✅ 0-BASED: First round is 0
  feedbackType: text('feedback_type', { enum: FEEDBACK_TYPES }), // null = no feedback
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .$onUpdate(() => /* @__PURE__ */ new Date())
    .notNull(),
}, table => [
  // ✅ Unique constraint: one feedback per user per round
  index('chat_round_feedback_unique_idx').on(table.threadId, table.userId, table.roundNumber),
  index('chat_round_feedback_thread_idx').on(table.threadId),
  index('chat_round_feedback_round_idx').on(table.threadId, table.roundNumber),
]);

/**
 * Pre-Search Results
 * Stores web search results executed BEFORE participant streaming
 * Follows same pattern as moderator analysis for consistency
 */
export const chatPreSearch = sqliteTable('chat_pre_search', {
  id: text('id').primaryKey(),
  threadId: text('thread_id')
    .notNull()
    .references(() => chatThread.id, { onDelete: 'cascade' }),
  roundNumber: integer('round_number').notNull(), // ✅ 0-BASED: First round is 0
  userQuery: text('user_query').notNull(), // The user's search query
  // ✅ CRITICAL: Status field for idempotency and state tracking
  // Prevents duplicate searches on page refresh
  // Uses ANALYSIS_STATUSES for consistency (pending/streaming/completed/failed)
  status: text('status', { enum: ANALYSIS_STATUSES })
    .notNull()
    .default('pending'), // pending -> streaming -> completed/failed
  // Store the full search results as JSON
  // ✅ NULLABLE: Only populated once search completes successfully
  // ✅ TAVILY-ENHANCED: Includes images, auto-parameters, enhanced metadata
  searchData: text('search_data', { mode: 'json' }).$type<{
    queries: Array<{
      query: string;
      rationale: string;
      searchDepth: import('@/api/core/enums').WebSearchDepth;
      index: number;
      total: number;
    }>;
    results: Array<{
      query: string;
      answer: string | null;
      results: Array<{
        title: string;
        url: string;
        content: string;
        excerpt?: string;
        fullContent?: string;
        rawContent?: string;
        score: number;
        publishedDate: string | null;
        domain?: string;
        contentType?: string;
        keyPoints?: string[];
        metadata?: {
          author?: string;
          readingTime?: number;
          wordCount?: number;
          description?: string;
          imageUrl?: string;
          faviconUrl?: string;
        };
        images?: Array<{
          url: string;
          description?: string;
          alt?: string;
        }>;
      }>;
      responseTime: number;
      // Tavily-style images array
      images?: Array<{
        url: string;
        description?: string;
      }>;
      // Auto-detected parameters
      autoParameters?: {
        topic?: import('@/api/core/enums').WebSearchTopic;
        timeRange?: import('@/api/core/enums').WebSearchTimeRange;
        searchDepth?: import('@/api/core/enums').WebSearchDepth;
        reasoning?: string;
      };
    }>;
    analysis: string; // Overall analysis of why these queries were chosen
    successCount: number;
    failureCount: number;
    totalResults: number;
    totalTime: number;
  }>(),
  // ✅ Error tracking for failed searches
  errorMessage: text('error_message'),
  // ✅ Completion timestamp (null until status = 'complete')
  completedAt: integer('completed_at', { mode: 'timestamp_ms' }),
  createdAt: integer('created_at', { mode: 'timestamp_ms' })
    .defaultNow()
    .notNull(),
}, table => [
  index('chat_pre_search_thread_idx').on(table.threadId),
  index('chat_pre_search_round_idx').on(table.threadId, table.roundNumber),
  index('chat_pre_search_created_idx').on(table.createdAt),
  index('chat_pre_search_status_idx').on(table.status),
  // ✅ UNIQUE CONSTRAINT: Only one pre-search per thread + round
  uniqueIndex('chat_pre_search_thread_round_unique').on(table.threadId, table.roundNumber),
]);

/**
 * Drizzle Relations for improved query support
 */
export const chatThreadRelations = relations(chatThread, ({ one, many }) => ({
  user: one(user, {
    fields: [chatThread.userId],
    references: [user.id],
  }),
  project: one(chatProject, {
    fields: [chatThread.projectId],
    references: [chatProject.id],
  }),
  participants: many(chatParticipant),
  messages: many(chatMessage),
  changelog: many(chatThreadChangelog), // Configuration change history
  moderatorAnalyses: many(chatModeratorAnalysis), // AI-generated round analyses
  preSearches: many(chatPreSearch), // Web search results for rounds
  roundFeedback: many(chatRoundFeedback), // User feedback for rounds
}));

export const chatCustomRoleRelations = relations(chatCustomRole, ({ one, many }) => ({
  user: one(user, {
    fields: [chatCustomRole.userId],
    references: [user.id],
  }),
  participants: many(chatParticipant), // Participants using this custom role
}));

export const chatParticipantRelations = relations(chatParticipant, ({ one, many }) => ({
  thread: one(chatThread, {
    fields: [chatParticipant.threadId],
    references: [chatThread.id],
  }),
  customRole: one(chatCustomRole, {
    fields: [chatParticipant.customRoleId],
    references: [chatCustomRole.id],
  }),
  messages: many(chatMessage),
}));

export const chatMessageRelations = relations(chatMessage, ({ one, many }) => ({
  thread: one(chatThread, {
    fields: [chatMessage.threadId],
    references: [chatThread.id],
  }),
  participant: one(chatParticipant, {
    fields: [chatMessage.participantId],
    references: [chatParticipant.id],
  }),
  // ✅ ATTACHMENTS: Link to uploaded files via junction table
  messageUploads: many(messageUpload),
  // ✅ REMOVED: parentMessage relation (parentMessageId moved to metadata)
  // Parent message relationship is now tracked via metadata.parentMessageId
}));

/**
 * Changelog Relations
 */
export const chatThreadChangelogRelations = relations(chatThreadChangelog, ({ one }) => ({
  thread: one(chatThread, {
    fields: [chatThreadChangelog.threadId],
    references: [chatThread.id],
  }),
}));

/**
 * Moderator Analysis Relations
 */
export const chatModeratorAnalysisRelations = relations(chatModeratorAnalysis, ({ one }) => ({
  thread: one(chatThread, {
    fields: [chatModeratorAnalysis.threadId],
    references: [chatThread.id],
  }),
}));

/**
 * Pre-Search Relations
 */
export const chatPreSearchRelations = relations(chatPreSearch, ({ one }) => ({
  thread: one(chatThread, {
    fields: [chatPreSearch.threadId],
    references: [chatThread.id],
  }),
}));

/**
 * Round Feedback Relations
 */
export const chatRoundFeedbackRelations = relations(chatRoundFeedback, ({ one }) => ({
  thread: one(chatThread, {
    fields: [chatRoundFeedback.threadId],
    references: [chatThread.id],
  }),
  user: one(user, {
    fields: [chatRoundFeedback.userId],
    references: [user.id],
  }),
}));
