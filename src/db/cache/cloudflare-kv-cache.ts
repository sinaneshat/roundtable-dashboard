/**
 * Cloudflare KV Cache for Drizzle ORM
 *
 * Implements Drizzle's caching extension using Cloudflare KV storage.
 * Optimized for Cloudflare Workers environment with D1 database.
 *
 * Features:
 * - Automatic cache invalidation on mutations
 * - Configurable TTL per query
 * - Table-based cache key management
 * - Custom tag support for manual invalidation
 *
 * @see https://orm.drizzle.team/docs/cache
 */

import type { Table as TableType } from 'drizzle-orm';
import { getTableName, is, Table } from 'drizzle-orm';
import { Cache } from 'drizzle-orm/cache/core';
import type { CacheConfig } from 'drizzle-orm/cache/core/types';

/**
 * Configuration options for CloudflareKVCache
 */
export type CloudflareKVCacheOptions = {
  /** KV namespace binding from Cloudflare Workers */
  kv: KVNamespace;
  /**
   * Cache strategy:
   * - 'explicit': Cache only when .$withCache() is called (default)
   * - 'all': Cache all SELECT queries globally
   */
  global?: boolean;
  /**
   * Default TTL in seconds for cached queries
   * @default 300 (5 minutes)
   */
  defaultTtl?: number;
  /**
   * Prefix for all cache keys to avoid collisions
   * @default 'drizzle:'
   */
  keyPrefix?: string;
};

/**
 * Cloudflare KV Cache implementation for Drizzle ORM
 *
 * This cache implementation uses Cloudflare KV for storing query results
 * and automatically invalidates cache entries when mutations occur on tracked tables.
 *
 * @example
 * ```ts
 * import { CloudflareKVCache } from '@/db/cache/cloudflare-kv-cache';
 *
 * const db = drizzle(env.DB, {
 *   schema,
 *   cache: new CloudflareKVCache({
 *     kv: env.KV,
 *     global: false, // Opt-in caching
 *     defaultTtl: 300, // 5 minutes
 *   }),
 * });
 *
 * // Opt-in to caching for specific query
 * const users = await db.select().from(usersTable).$withCache();
 *
 * // With custom TTL
 * const products = await db.select().from(productsTable)
 *   .$withCache({ config: { ex: 600 } }); // 10 minutes
 *
 * // With custom cache key
 * const featured = await db.select().from(productsTable)
 *   .where(eq(productsTable.featured, true))
 *   .$withCache({ tag: 'featured-products' });
 *
 * // Manual invalidation
 * await db.$cache.invalidate({ tables: [usersTable] });
 * await db.$cache.invalidate({ tags: ['featured-products'] });
 * ```
 */
export class CloudflareKVCache extends Cache {
  private kv: KVNamespace;
  private defaultTtl: number;
  private globalCache: boolean;
  private keyPrefix: string;

  /**
   * In-memory tracking of which cache keys use which tables
   * This allows efficient invalidation when tables are mutated
   *
   * Structure: { tableName: [cacheKey1, cacheKey2, ...] }
   */
  private tableToKeys: Record<string, Set<string>> = {};

  constructor(options: CloudflareKVCacheOptions) {
    super();
    this.kv = options.kv;
    this.defaultTtl = options.defaultTtl ?? 300; // 5 minutes default
    this.globalCache = options.global ?? false;
    this.keyPrefix = options.keyPrefix ?? 'drizzle:';
  }

  /**
   * Define cache strategy
   * - 'explicit': Only cache queries with .$withCache() (default)
   * - 'all': Cache all SELECT queries globally
   */
  override strategy(): 'explicit' | 'all' {
    return this.globalCache ? 'all' : 'explicit';
  }

  /**
   * Retrieve cached query results from KV
   *
   * @param key - Hashed query identifier (generated by Drizzle)
   * @returns Cached results or undefined if not found or expired
   */
  override async get(
    key: string,
  ): Promise<unknown[] | undefined> {
    try {
      const prefixedKey = this.getPrefixedKey(key);
      const cached = await this.kv.get<unknown[]>(prefixedKey, 'json');

      if (cached !== null) {
        return cached;
      }

      return undefined;
    } catch (error) {
      console.error('[Cache] Error retrieving from KV:', error);
      return undefined;
    }
  }

  /**
   * Store query results in KV cache
   *
   * @param hashedQuery - Hashed query identifier
   * @param response - Query results to cache (array of database rows)
   * @param tables - Tables involved in the query (for invalidation tracking)
   * @param isTag - Whether this is a custom-tagged query
   * @param config - Cache configuration (TTL, etc.)
   */
  override async put(
    hashedQuery: string,
    response: unknown[],
    tables: string[],
    isTag: boolean,
    config?: CacheConfig,
  ): Promise<void> {
    try {
      const prefixedKey = this.getPrefixedKey(hashedQuery);

      // Calculate expiration
      const ttl = this.calculateTtl(config);

      // Store in KV with expiration
      await this.kv.put(prefixedKey, JSON.stringify(response), {
        expirationTtl: ttl,
      });

      // Track which tables this cache key uses (for invalidation)
      // Only track if not a custom tag
      if (!isTag) {
        for (const table of tables) {
          if (!this.tableToKeys[table]) {
            this.tableToKeys[table] = new Set();
          }
          this.tableToKeys[table].add(hashedQuery);
        }
      }

      // Successfully stored in cache
    } catch (error) {
      console.error('[Cache] Error storing to KV:', error);
    }
  }

  /**
   * Invalidate cache entries when mutations occur
   * Called automatically by Drizzle on INSERT, UPDATE, DELETE
   *
   * @param params - Invalidation parameters
   * @param params.tags - Tags to invalidate (string or array of strings)
   * @param params.tables - Tables to invalidate (string, array, or table objects)
   */
  override async onMutate(params: {
    tags: string | string[];
    tables: string | string[] | TableType | TableType[];
  }): Promise<void> {
    try {
      const tagsArray = this.normalizeToArray(params.tags);
      const tablesArray = this.normalizeToArray(params.tables);

      // Collect all keys to invalidate
      const keysToInvalidate = new Set<string>();

      // Invalidate by tables
      for (const table of tablesArray) {
        const tableName = this.getTableName(table);
        const keys = this.tableToKeys[tableName];

        if (keys) {
          keys.forEach(key => keysToInvalidate.add(key));
          // Clear the tracking for this table
          delete this.tableToKeys[tableName];
        }
      }

      // Invalidate by custom tags
      for (const tag of tagsArray) {
        keysToInvalidate.add(tag);
      }

      // Delete all affected keys from KV
      if (keysToInvalidate.size > 0) {
        await Promise.all(
          Array.from(keysToInvalidate).map(key =>
            this.kv.delete(this.getPrefixedKey(key)),
          ),
        );

        // Keys invalidated successfully
      }
    } catch (error) {
      console.error('[Cache] Error during invalidation:', error);
    }
  }

  /**
   * Manual cache invalidation helper
   * Useful for custom invalidation logic outside of Drizzle's automatic tracking
   */
  async invalidate(params: {
    tables?: string | string[] | TableType | TableType[];
    tags?: string | string[];
  }): Promise<void> {
    await this.onMutate({
      tags: params.tags ?? [],
      tables: params.tables ?? [],
    });
  }

  /**
   * Clear all cache entries with the configured prefix
   * USE WITH CAUTION: This clears all Drizzle cache entries
   */
  async clearAll(): Promise<void> {
    try {
      // Note: KV doesn't have a native "delete by prefix" operation
      // We can only clear tracked keys
      const allKeys = new Set<string>();

      Object.values(this.tableToKeys).forEach((keys) => {
        keys.forEach(key => allKeys.add(key));
      });

      if (allKeys.size > 0) {
        await Promise.all(
          Array.from(allKeys).map(key =>
            this.kv.delete(this.getPrefixedKey(key)),
          ),
        );
      }

      // Clear tracking
      this.tableToKeys = {};

      // All cache entries cleared
    } catch (error) {
      console.error('[Cache] Error clearing cache:', error);
    }
  }

  // ============================================================================
  // Private Helper Methods
  // ============================================================================

  /**
   * Add prefix to cache keys to avoid collisions with other KV data
   */
  private getPrefixedKey(key: string): string {
    return `${this.keyPrefix}${key}`;
  }

  /**
   * Calculate TTL from cache config, with fallback to default
   */
  private calculateTtl(config?: CacheConfig): number {
    if (config?.ex)
      return config.ex;
    if (config?.px)
      return Math.floor(config.px / 1000);
    if (config?.exat)
      return Math.max(0, config.exat - Math.floor(Date.now() / 1000));
    if (config?.pxat)
      return Math.max(0, Math.floor((config.pxat - Date.now()) / 1000));
    return this.defaultTtl;
  }

  /**
   * Normalize tags/tables to array format
   */
  private normalizeToArray<T>(value: T | T[]): T[] {
    if (!value)
      return [];
    return Array.isArray(value) ? value : [value];
  }

  /**
   * Extract table name from Table object or string
   */
  private getTableName(table: string | TableType): string {
    return is(table, Table) ? getTableName(table) : table;
  }
}
